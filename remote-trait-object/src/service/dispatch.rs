// Copyright 2020 Kodebox, Inc.
// This file is part of CodeChain.
//
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU Affero General Public License as
// published by the Free Software Foundation, either version 3 of the
// License, or (at your option) any later version.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU Affero General Public License for more details.
//
// You should have received a copy of the GNU Affero General Public License
// along with this program.  If not, see <https://www.gnu.org/licenses/>.

use super::table::ServiceObjectTable;
use super::{MethodId, Service, ServiceObjectId};
use parking_lot::RwLock;
use std::sync::Arc;

// 1. PortDispatcher: Dispatch given packet to the target instance.
// This process is general over traits.
// 2. ServiceDispatcher: Dispatch given packet (which has been dispatched by PortDispatcher)
// to the target method. This process is very specific to each trait,
// and is generated by the proc macro.

pub trait ServiceDispatcher: Send + Sync {
    fn dispatch(&self, method: MethodId, arguments: &[u8], return_buffer: std::io::Cursor<&mut Vec<u8>>);
}

pub struct PortDispatcher {
    service_table: RwLock<ServiceObjectTable>,
}

impl PortDispatcher {
    pub fn new(size: usize) -> Self {
        PortDispatcher {
            service_table: RwLock::new(ServiceObjectTable::new(size)),
        }
    }

    pub fn dispatch(
        &self,
        handle: ServiceObjectId,
        method: MethodId,
        arguments: &[u8],
        return_buffer: std::io::Cursor<&mut Vec<u8>>,
    ) {
        #[cfg(statistics)]
        {
            crate::statistics::DISPATCH_COUNT.fetch_add(1, std::sync::atomic::Ordering::SeqCst);
        }
        let service_object = self.service_table.read().get(handle.index as usize);
        assert_ne!(service_object.get_handle().port.strong_count(), 0);

        // NOTE: You must drop the ReadGuard before dispatch (if not deadlock)
        super::serde_support::port_thread_local::set_port(service_object.get_handle().port.clone());
        service_object.dispatch(method, arguments, return_buffer);
        super::serde_support::port_thread_local::remove_port();
    }

    pub fn register(&self, handle_to_register: Arc<dyn Service>) -> ServiceObjectId {
        #[cfg(statistics)]
        {
            crate::statistics::CREATE_COUNT.fetch_add(1, std::sync::atomic::Ordering::SeqCst);
        }
        self.service_table.write().create(handle_to_register).get_handle().id
    }

    pub fn delete(&self, id: ServiceObjectId) {
        self.service_table.write().remove(id.index as usize)
    }
}
